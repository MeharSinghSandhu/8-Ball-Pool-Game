from http.server import HTTPServer, BaseHTTPRequestHandler
import os
import math
import urllib.parse
from urllib.parse import urlparse  # Corrected import
from urllib.parse import parse_qs

import Physics
import sys; # used to get argv
import cgi; # used to parse Mutlipart FormData 
            # this should be replace with multipart in the future
import random
import json

# web server parts

# used to parse the URL and extract form data for GET requests
def nudge():
    # Return a small random float, e.g., between -1.0 and 1.0
    return random.uniform(-1.0, 1.0)
    
def add_ball(table, number, x_pos, y_pos):
    ball_position = Physics.Coordinate(x_pos, y_pos)
    ball = Physics.StillBall(number, ball_position)  # Assuming all balls are initially still
    table += ball
    return table
    
    

class PhysicsServerHandler(BaseHTTPRequestHandler):
    game = None
    table =None
    
    def serve_file(self, path):
        try:
            with open(path, 'rb') as file:
                self.send_response(200)
                content_type = 'text/html'
                if path.endswith('.svg'):
                    content_type = 'image/svg+xml'
                self.send_header('Content-type', content_type)
                self.end_headers()
                self.wfile.write(file.read())
        except FileNotFoundError:
            self.send_error(404, 'File Not Found')


    def do_GET(self):
        # parse the URL to get the path and form data
        parsed  = urlparse( self.path );

        # check if the web-pages matches the list
        if parsed.path in [ '/shoot.html' ]:

            # retreive the HTML file
            fp = open( '.'+self.path );
            content = fp.read();

            # generate the headers
            self.send_response( 200 ); # OK
            self.send_header( "Content-type", "text/html" );
            self.send_header( "Content-length", len( content ) );
            self.end_headers();

            # send it to the broswer
            self.wfile.write( bytes( content, "utf-8" ) );
            fp.close();
        elif parsed.path in [ '/shoot.js' ]:
            fp = open( './shoot.js' );
            content = fp.read();
            # generate the headers
            self.send_response( 200 ); # OK
            self.send_header( "Content-type", "text/html" );
            self.send_header( "Content-length", len( content ) );
            self.end_headers();
            self.wfile.write( bytes( content, "utf-8" ) );
            fp.close();
            
            
        
        # elif parsed.path.endswith(".svg"):
        # # This condition will serve any .svg files, including those generated by your simulation
        #     try:
        #     # Open and read the SVG file
        #         with open('.' + parsed.path, 'r') as fp:
        #             content = fp.read()

        #     # Send the response headers
        #         self.send_response(200)  # OK
        #         self.send_header("Content-type", "image/svg+xml")
        #         self.send_header("Content-length", len(content))
        #         self.end_headers()

        #     # Write the content of the SVG file to the response
        #         self.wfile.write(bytes(content, "utf-8"))
        
            # except FileNotFoundError:
            # # Handle file not found error
            #     self.send_error(404, "File Not Found", f"The requested file {parsed.path} does not exist on the server.")

        else:
            # generate 404 for GET requests that aren't the 3 files above
            self.send_response( 404 );
            self.end_headers();
            self.wfile.write( bytes( "404: %s not found" % self.path, "utf-8" ))
    

    # def do_POST(self):
    #     if self.path == "/display.html":
            
    #         # Get the size of data
    #         content_length = int(self.headers['Content-Length'])  # Get the size of data
    #         post_data = self.rfile.read(content_length).decode('utf-8')  # Read the data
    #         form_data = urllib.parse.parse_qs(post_data)  # Parse the form data from POST
    #         # Extract form data for multipart (assuming field names are the same as in URL-encoded form)
    #         sb_x = float(form_data['sb_x'][0])
    #         sb_y = float(form_data['sb_y'][0])
    #         rb_x = float(form_data['rb_x'][0])
    #         rb_y = float(form_data['rb_y'][0])
    #         rb_dx = float(form_data['rb_dx'][0])
    #         rb_dy = float(form_data['rb_dy'][0])
            
    #         sb_number = int(form_data['sb_number'][0])
    #         rb_number = int(form_data['rb_number'][0])
            
    #     else:
    #         # Handle URL-encoded form data
    #         content_length = int(self.headers['Content-Length'])
    #         post_data = self.rfile.read(content_length).decode('utf-8')
    #         form_data = urllib.parse.parse_qs(post_data)
    #         sb_x = float(form_data['sb_x'][0])
    #         sb_y = float(form_data['sb_y'][0])
    #         rb_x = float(form_data['rb_x'][0])
    #         rb_y = float(form_data['rb_y'][0])
    #         rb_dx = float(form_data['rb_dx'][0])
    #         rb_dy = float(form_data['rb_dy'][0])
    #     # Initialize the Physics simulation
    #     table = Physics.Table()
        

    #     # Calculate positions based on form data
        # sb_pos = Physics.Coordinate(675, 654)
    #     rb_pos = Physics.Coordinate(rb_x, rb_y)
    #     rb_vel = Physics.Coordinate(rb_dx, rb_dy)
    #     rb_acc_magnitude = math.sqrt(rb_dx**2 + rb_dy**2)
    #     rb_acc = Physics.Coordinate(-Physics.DRAG * rb_dx / rb_acc_magnitude if rb_acc_magnitude != 0 else 0,
    #                                 -Physics.DRAG * rb_dy / rb_acc_magnitude if rb_acc_magnitude != 0 else 0)

    #     # Create StillBall and RollingBall
        # sb = Physics.StillBall(s0, sb_pos)  # Assuming ball number 1 for StillBall
    #     rb = Physics.RollingBall(rb_number, rb_pos, rb_vel, rb_acc)  # Assuming ball number 0 for RollingBall

    #     # Add balls to the table
        # table += sb
    #     table += rb
        

    #     count = 0

    #     file = open("table-%d.svg" % (count), "w")
    #     file.write(table.svg());

    #     count += 1

    #     while table:
  
    #         table = table.segment()
    #         if table: 
    #             file = open("table-%d.svg" % (count), "w")
    #             file.write(table.svg());

    #             count += 1
            
        

    #     # Generate HTML response with SVG images
    #     html_response = "<html><head><title>Simulation Results</title></head><body>"
        
    #     # Dynamically add image tags for each SVG file based on the count
    #     for i in range(count):
    #         html_response += f'<img src="/table-{i}.svg" alt="Simulation step {i}"/><br/>'
    #     html_response += '<a href="/shoot.html">Back to Form</a>'
    #     html_response += "</body></html>"


    #     self.send_response(200)
    #     self.send_header("Content-type", "text/html")
    #     self.end_headers()
    #     self.wfile.write(html_response.encode('utf-8'))
    
    
    def do_POST(self):
        
        if self.path == "/display.html":
            content_length = int(self.headers['Content-Length'])  # <--- Gets the size of data
            post_data = self.rfile.read(content_length)  # <--- Gets the data itself
            post_data = post_data.decode('utf-8')  # Decode data to string

        # Use urllib.parse.parse_qs to parse the query string
            parsed_data = parse_qs(post_data)

        # Extract player1, player2, and gamename values
            player1 = parsed_data.get('player1', [None])[0]
            player2 = parsed_data.get('player2', [None])[0]
            gamename = parsed_data.get('gamename', [None])[0]

            PhysicsServerHandler.game = Physics.Game(gameName=gamename, player1Name=player1, player2Name=player2)
            
            print(f"Game created with name: {gamename}, Player 1: {player1}, Player 2: {player2}")
            
            PhysicsServerHandler.table = Physics.Table()
            
                    # Add cue ball
            PhysicsServerHandler.table = add_ball(PhysicsServerHandler.table, 0, Physics.TABLE_WIDTH/2.0 + random.uniform(-3.0, 3.0),
                     Physics.TABLE_LENGTH - Physics.TABLE_WIDTH/2.0)

    # Add other balls
    # Row 1
            PhysicsServerHandler.table = add_ball(PhysicsServerHandler.table, 1, Physics.TABLE_WIDTH/2.0, Physics.TABLE_WIDTH/2.0)

    # Row 2
            PhysicsServerHandler.table = add_ball(PhysicsServerHandler.table, 2, Physics.TABLE_WIDTH/2.0 - (Physics.BALL_DIAMETER+4.0)/2.0 + nudge(),
                     Physics.TABLE_WIDTH/2.0 - math.sqrt(3.0)/2.0*(Physics.BALL_DIAMETER+4.0) + nudge())
            PhysicsServerHandler.table = add_ball(PhysicsServerHandler.table, 14, Physics.TABLE_WIDTH/2.0 + (Physics.BALL_DIAMETER+4.0)/2.0 + nudge(),
                     Physics.TABLE_WIDTH/2.0 - math.sqrt(3.0)/2.0*(Physics.BALL_DIAMETER+4.0) + nudge())

    # Row 3
            PhysicsServerHandler.table = add_ball(PhysicsServerHandler.table, 13, Physics.TABLE_WIDTH/2.0 + (Physics.BALL_DIAMETER + 5.0) + nudge(),
                     Physics.TABLE_WIDTH/2.0 - math.sqrt(3.0)/2.0 * ((Physics.BALL_DIAMETER*2.0)+10.0) + nudge())
            PhysicsServerHandler.table = add_ball(PhysicsServerHandler.table, 8, Physics.TABLE_WIDTH/2.0 + nudge(),
                     Physics.TABLE_WIDTH/2.0 - math.sqrt(3.0)/2.0 * ((Physics.BALL_DIAMETER * 2.0) + 10.0) + nudge())
            PhysicsServerHandler.table = add_ball(PhysicsServerHandler.table, 10, Physics.TABLE_WIDTH/2.0 - math.sqrt(3.0)/2.0 * ((Physics.BALL_DIAMETER * 2.0)-42.0) + nudge(),
                     Physics.TABLE_WIDTH/2.0 - math.sqrt(3.0)/2.0 * ((Physics.BALL_DIAMETER * 2.0) +10.0) + nudge())

    # Row 4
            PhysicsServerHandler.table = add_ball(PhysicsServerHandler.table, 6, Physics.TABLE_WIDTH/2.0 - math.sqrt(3.0)/2.0 * (Physics.BALL_DIAMETER + 50.0 ) + nudge(),
                     Physics.TABLE_WIDTH/2.0 - math.sqrt(3.0)/2.0 * ((Physics.BALL_DIAMETER * 3.0) + 20.0) + nudge())
            PhysicsServerHandler.table = add_ball(PhysicsServerHandler.table, 15, Physics.TABLE_WIDTH/2.0 - math.sqrt(3.0)/2.0 * (Physics.BALL_DIAMETER - 20.0) + nudge(),
                     Physics.TABLE_WIDTH/2.0 - math.sqrt(3.0)/2.0 * ((Physics.BALL_DIAMETER * 3.0) + 20.0) + nudge())
            PhysicsServerHandler.table = add_ball(PhysicsServerHandler.table, 12, Physics.TABLE_WIDTH/2.0 - math.sqrt(3.0)/2.0 * (Physics.BALL_DIAMETER - 90.0) + nudge(),
                     Physics.TABLE_WIDTH/2.0 - math.sqrt(3.0)/2.0 * ((Physics.BALL_DIAMETER * 3.0) + 20.0) + nudge())
            PhysicsServerHandler.table = add_ball(PhysicsServerHandler.table, 3, Physics.TABLE_WIDTH/2.0 - math.sqrt(3.0)/2.0 * (Physics.BALL_DIAMETER - 160.0) + nudge(),
                     Physics.TABLE_WIDTH/2.0 - math.sqrt(3.0)/2.0 * ((Physics.BALL_DIAMETER * 3.0) + 20.0) + nudge())

    # Row 5
            PhysicsServerHandler.table = add_ball(PhysicsServerHandler.table, 4, Physics.TABLE_WIDTH/2.0 + nudge(),
                     Physics.TABLE_WIDTH/2.0 - math.sqrt(3.0)/2.0 * ((Physics.BALL_DIAMETER * 4.0) + 25.0) + nudge())
            PhysicsServerHandler.table = add_ball(PhysicsServerHandler.table, 7, Physics.TABLE_WIDTH/2.0 - math.sqrt(3.0)/2.0 * ((Physics.BALL_DIAMETER * 3.0) - 25.0) + nudge(),
                     Physics.TABLE_WIDTH/2.0 - math.sqrt(3.0)/2.0 * ((Physics.BALL_DIAMETER * 4.0) + 25.0) + nudge())
            PhysicsServerHandler.table = add_ball(PhysicsServerHandler.table, 9, Physics.TABLE_WIDTH/2.0 - math.sqrt(3.0)/2.0 * ((Physics.BALL_DIAMETER * 2.0) - 40.0) + nudge(),
                     Physics.TABLE_WIDTH/2.0 - math.sqrt(3.0)/2.0 * ((Physics.BALL_DIAMETER * 4.0) + 25.0) + nudge())
            PhysicsServerHandler.table = add_ball(PhysicsServerHandler.table, 11, Physics.TABLE_WIDTH/2.0 - math.sqrt(3.0)/2.0 * (Physics.BALL_DIAMETER - 130.0) + nudge(),
                     Physics.TABLE_WIDTH/2.0 - math.sqrt(3.0)/2.0 * ((Physics.BALL_DIAMETER * 4.0) + 25.0) + nudge())
            PhysicsServerHandler.table = add_ball(PhysicsServerHandler.table, 5, Physics.TABLE_WIDTH/2.0 - math.sqrt(3.0)/2.0 * (Physics.BALL_DIAMETER - 200.0) + nudge(),
                     Physics.TABLE_WIDTH/2.0 - math.sqrt(3.0)/2.0 * ((Physics.BALL_DIAMETER * 4.0) + 25.0) + nudge())

            
            svg_content = PhysicsServerHandler.table.svg()
        # Generate HTML response with the SVG
            # Start building the HTML response
            html_response = f"""
            <!DOCTYPE html>
            <html>
            <head>
            <style>
            body {{
            background-color: grey;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            color: white;
        }}
        #gameArea {{
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            max-width: 1200px; /* Adjust based on your SVG size */
        }}
        #player1, #player2 {{
            margin: 20px;
            font-size: 24px; /* Adjust font size as needed */
        }}
        svg {{
            margin-bottom : 20%
            max-height: 100%;
            max-width: 100%;
        }}
            </style>
            <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.3/jquery.min.js"></script>
            <script src="shoot.js"></script>
            <title>Game Setup</title>
            </head>
            <body>
            
        <div id="gameArea">
        <div id="player1">{player1}</div>
        <div id="player2">{player2}</div>
        
        
        
        </div>
            <br/><a href='/shoot.html' style="color: white;">Back to Form</a>
            
            
            """
            html_response += svg_content
            html_response+="""
            </body>
            </html>
            """

            
            
            self.send_response(200)
            self.send_header("Content-type", "text/html")
            self.end_headers()
            self.wfile.write(html_response.encode('utf-8'))
            
        elif self.path == "/process_velocity":
            content_length = int(self.headers['Content-Length'])
            post_data = self.rfile.read(content_length)
            data = json.loads(post_data.decode('utf-8'))

            velocity_x = float(data['velocityX'])
            velocity_y = float(data['velocityY'])
            
            svgs= None
            
            svgs, PhysicsServerHandler.table = PhysicsServerHandler.game.shoot(" ", " ",PhysicsServerHandler.table, velocity_x, velocity_y)

        
        # Process the velocity here, such as updating the physics simulation
        
        # Respond to the client
            self.send_response(200)
            self.send_header('Content-type', 'application/json')
            self.end_headers()
            
            
            
            self.wfile.write(json.dumps(svgs).encode('utf-8'))
        else:
            # Handle other POST paths if necessary
            self.send_error(404, "File Not Found", f"The requested path {self.path} is not supported for POST requests.")
    




def run(server_class=HTTPServer, handler_class=PhysicsServerHandler, port=55000):
    server_address = ('', port)
    httpd = server_class(server_address, handler_class)
    print(f"Starting server on port {port}...")
    httpd.serve_forever()

if __name__ == "__main__":
    from sys import argv
    if len(argv) == 2:
        port = int(argv[1])
    else:
        port = 55000  # Default port if not provided
    run(port=port)
    
    

                